<% content_for :title, "Meal Calorie Tracker" %>
<% content_for :modals do %>
  <div id="cmodal-backdrop" class="cmodal-backdrop hidden">
    <div class="cmodal">
      <h3 id="cmodal-title">Edit Item</h3>
      <div class="row">
        <input id="m-cat" class="sm" placeholder="Category">
        <input id="m-name" placeholder="Name">
        <input id="m-cal" class="sm basic" type="number" placeholder="Calories">
      </div>
      <div class="row">
        <input id="m-img" placeholder="Image URL or emoji">
      </div>
      <div class="row">
        <input id="m-tag" placeholder="Tag / helper text">
      </div>
      <div class="cmodal-actions">
        <button id="m-delete" class="danger primary" type="button">Delete</button>
        <div class="spacer"></div>
        <button id="m-cancel" class="primary" type="button">Cancel</button>
        <button id="m-save" class="ok primary" type="button">Done</button>
      </div>
    </div>
  </div>

  <div id="qmodal-backdrop" class="cmodal-backdrop hidden">
    <div class="cmodal">
      <h3>Quick Edit</h3>
      <textarea id="q-text" rows="12" wrap="off"
        style="width:100%;padding:8px 10px;border:1px solid #CCC;border-radius:6px;
              font-family: ui-monospace, SFMono-Regular, Menlo, monospace"></textarea>
      <div class="cmodal-actions">
        <div class="spacer"></div>
        <button id="q-cancel" class="primary" type="button">Cancel</button>
        <button id="q-apply" class="ok primary" type="button">Apply</button>
      </div>
    </div>
  </div>
<% end %>

<div class="wrap" data-save-url="<%= meal_builder_path(@meal_builder) %>">
  <div class="topbar">
    <button id="toggle-edit" class="primary" type="button">‚öôÔ∏è</button>
    <button id="save-items" class="primary" type="button" class="hidden">üíæ</button>
    <button id="add-item" class="primary" type="button" class="hidden">‚ûï</button>
    <button id="quick-edit" class="primary" type="button" class="hidden">‚úçÔ∏è</button>

    <input id="search" type="search" placeholder="Search food..." autocomplete="off">
    <%= link_to "‚úèÔ∏è Edit Page", edit_meal_builder_path(@meal_builder), class: "btn primary hidden", id: "page-edit" %>
    <button id="submit" class="primary" disabled>Submit</button>
  </div>
  <div id="grid" class="grid"></div>
</div>

<% content_for :after_body do %>
  <script id="items-data" type="application/json">
    <%= raw(@meal_builder.items.to_json) %>
  </script>

  <style>
    html, body { margin: 0; padding: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px 20px 28px }
    .topbar { display: flex; gap: 12px; align-items: center; margin-bottom: 12px }
    input[type="text"] {
      flex: 1; padding: 10px 12px; border: 1px solid #CCC;
      border-radius: 8px; outline: none
    }
    button {
      padding: inherit;
    }
    button.primary {
      padding: 6px 10px; border: none; border-radius: 8px;
      background: #2563EB; color: black; cursor: pointer
    }
    button.primary:disabled { opacity: .5; cursor: default }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
      gap: 12px
    }
    @media (max-width: 600px) {
      .grid { grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)) }
    }
    .card-styles {
      color: #ECF0F1;
      border-width: 1px;
      border-style: solid;
      border-color: #D5E5FF;
      border-image: initial;
      background: #00102B;
    }
    .card {
      position: relative; border: 1px solid #E5E7EB; border-radius: 12px;
      padding: 6px; display: flex; flex-direction: column; gap: 4px;
      align-items: center; justify-content: space-between; background: #00102B;
      transition: transform .08s ease, box-shadow .08s ease
    }
    .card:hover { transform: translateY(-1px); box-shadow: 0 2px 10px #0001 }
    .card.selected { outline: 2px solid #22C55E; background: #0C3A30 }
    .imgbox {
      display: grid;
      place-items: center;
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 10px; background: #D5E5FF;
      overflow: hidden;
    }

    .imgbox i.emoji {
      position: relative;
      width: 100%;
      height: 100%;
      font-style: normal;
      font-size: 64px;
      line-height: 1;
      white-space: pre;
      pointer-events: none;
    }

    .imgbox i.emoji span {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      line-height: 1;
      pointer-events: none;
    }
    .imgbox img { width: 100%; height: 100%; object-fit: cover }
    .title { text-align: center; font-size: 14px; line-height: 1.2 }
    .cal { font-size: 12px; color: #6B7280 }
    .controls {
      display: flex; align-items: center; justify-content: space-between;
      width: 100%;
    }
    .pill {
      min-width: 20px; height: 20px; border-radius: 999px; border: 1px solid #D1D5DB;
      background: #FFF; cursor: pointer; display: grid; place-items: center;
      font-weight: 600
    }
    .count { min-width: 24px; text-align: center }
    .sticky-note {
      position: absolute; top: 8px; left: 8px; font-size: 12px;
      background: #22C55E; color: #FFF; padding: 2px 6px; border-radius: 999px
    }

    .editing .card { cursor: grab }
    .editing .card:active { cursor: grabbing }

    .card-overlay {
      position: absolute; inset: 0;
      background: #0008; border-radius: 12px;
      display: grid; place-items: center; text-align: center;
      color: #ECF0F1; font-weight: 600; font-size: 14px;
      pointer-events: auto
    }
    .card-overlay .hint {
      padding: 6px 10px; border-radius: 999px;
      background: #2563EB; color: #FFF
    }

    .drag-placeholder {
      border: 2px dashed #93C5FD;
      background: #EFF6FF;
      border-radius: 12px;
      height: 100%;
      min-height: 160px;
    }

    .dragging { opacity: .3 }

    .row { display: flex; gap: 8px; width: 100% }
    .row input {
      flex: 1; padding: 8px 10px; border: 1px solid #CCC; border-radius: 6px
    }
    .row .sm { max-width: 130px }

    .cmodal-backdrop {
      position: fixed; inset: 0; background: #0008;
      display: grid; place-items: center; z-index: 1000
    }
    .cmodal {
      width: min(560px, 92vw); background: #00102B; color: #ECF0F1;
      border: 1px solid #D5E5FF; border-radius: 12px; padding: 16px
    }
    .cmodal h3 { margin: 0 0 10px 0; font-size: 18px }
    .cmodal-actions {
      display: flex; align-items: center; gap: 2px; margin-top: 12px
    }
    .cmodal .ok, .cmodal .danger, .cmodal button {
      border: none; border-radius: 8px; cursor: pointer
    }
    .cmodal .ok { background: #2563EB; color: #FFF }
    .cmodal .danger { background: #991B1B; color: #FFF }
    .cmodal .spacer { flex: 1 }

    .hidden { display: none }
  </style>

  <script type="module">
    import { command } from "../../quick_actions/command.js";
    import { showFlash } from "../../quick_actions/flash.js";

    let ITEMS = JSON.parse(
      document.getElementById("items-data").textContent || "[]"
    )

    const picked = new Map()
    let query = ""
    let editMode = false

    const elGrid = document.getElementById("grid")
    const elSearch = document.getElementById("search")
    const elSubmit = document.getElementById("submit")
    const elToggleEdit = document.getElementById("toggle-edit")
    const elAddItem = document.getElementById("add-item")
    const elSaveItems = document.getElementById("save-items")
    const elQuickEdit = document.getElementById("quick-edit")
    const elPageEdit = document.getElementById("page-edit")
    const SAVE_ENDPOINT = document.querySelector(".wrap")?.dataset.saveUrl

    const elcModal = document.getElementById("cmodal-backdrop")
    const mTitle = document.getElementById("cmodal-title")
    const mName = document.getElementById("m-name")
    const mCat = document.getElementById("m-cat")
    const mCal = document.getElementById("m-cal")
    const mImg = document.getElementById("m-img")
    const mTag = document.getElementById("m-tag")
    const mSave = document.getElementById("m-save")
    const mCancel = document.getElementById("m-cancel")
    const mDelete = document.getElementById("m-delete")
    let currentEditingName = null
    let isNewItem = false

    const elQModal = document.getElementById("qmodal-backdrop")
    const elQText = document.getElementById("q-text")
    const elQApply = document.getElementById("q-apply")
    const elQCancel = document.getElementById("q-cancel")

    const csrfToken = () => {
      const m = document.querySelector('meta[name="csrf-token"]')
      return m ? m.content : ""
    }

    const fuzzyMatch = (needle, hay) => {
      if (!needle) return true
      let i = 0, j = 0
      const n = needle.toLowerCase(), h = hay.toLowerCase()
      while (i < n.length && j < h.length) { if (n[i] === h[j]) i++; j++ }
      return i === n.length
    }

    const splitGraphemes = s => {
      if (window.Intl && Intl.Segmenter) {
        const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" })
        return Array.from(seg.segment(s), x => x.segment)
      }
      return Array.from(s)
    }

    const computeView = () => {
      return ITEMS.filter(it =>
        fuzzyMatch(query, `${it.category} ${it.name} ${it.tag || ""}`)
      )
    }
    const keyOf = it => `${it.category}|${it.name}`
    const updateSubmit = () => { elSubmit.disabled = picked.size === 0 }

    const upsertItem = (name, attrs) => {
      const idx = ITEMS.findIndex(x => x.name === name)
      if (idx === -1) return
      ITEMS[idx] = { ...ITEMS[idx], ...attrs }
    }

    const deleteItem = name => {
      ITEMS = ITEMS.filter(x => x.name !== name)
      picked.delete(name)
    }

    // ---------- Drag & drop with placeholder (name-based) ----------
    let dragFromIdx = null
    let placeholder = null

    const startDrag = (fromIdx, card) => {
      dragFromIdx = fromIdx
      card.classList.add("dragging")
      placeholder = document.createElement("div")
      placeholder.className = "card drag-placeholder"
      placeholder.style.height = `${card.offsetHeight}px`
      elGrid.insertBefore(placeholder, card.nextSibling)
    }

    const finishDrag = draggedCard => {
      if (dragFromIdx == null || !placeholder) return
      const cards = Array.from(elGrid.querySelectorAll(".card"))
      const toIdx = cards.indexOf(placeholder)
      const moved = ITEMS.splice(dragFromIdx, 1)[0]
      const insertAt = Math.max(0, Math.min(toIdx, ITEMS.length))
      ITEMS.splice(insertAt, 0, moved)
      draggedCard.classList.remove("dragging")
      placeholder.remove()
      placeholder = null
      dragFromIdx = null
      render()
    }

    const movePlaceholder = (targetCard, clientY) => {
      if (!placeholder || !targetCard || targetCard === placeholder) return
      const rect = targetCard.getBoundingClientRect()
      const before = (clientY - rect.top) < rect.height / 2
      if (before) elGrid.insertBefore(placeholder, targetCard)
      else elGrid.insertBefore(placeholder, targetCard.nextSibling)
    }

    // ---------- Edit Modal ----------
    const opencModal = item => {
      mCat.dataset.prevCategory = item?.category || "Food"
      currentEditingName = item?.name || null
      isNewItem = !item
      mTitle.textContent = isNewItem ? "Add Item" : "Edit Item"
      mName.value = item?.name || ""
      mCal.value = item?.cal != null ? String(item.cal) : ""
      mCat.value = item?.category || "Food"
      mImg.value = item?.img || ""
      mTag.value = item?.tag || ""
      mDelete.classList.toggle("hidden", isNewItem)
      elcModal.classList.remove("hidden")
      setTimeout(() => mName.focus(), 0)
    }

    const closecModal = () => {
      elcModal.classList.add("hidden")
      currentEditingName = null
      isNewItem = false
    }

    mCancel.addEventListener("click", () => closecModal())

    mSave.addEventListener("click", () => {
      const category = (mCat.value.trim() || "Food").replace(/\s+/g, "")
      const name = mName.value.trim() || "Untitled"
      const calVal = parseInt(mCal.value || "0", 10)
      const cal = Math.max(0, Number.isFinite(calVal) ? calVal : 0)
      const img = mImg.value.trim()
      const tag = mTag.value.trim()
      if (isNewItem) {
        ITEMS.push({ category, name, cal, img, tag })
      } else {
        const idx = ITEMS.findIndex(x =>
          x.name === currentEditingName && x.category === mCat.dataset.prevCategory
        )
        if (idx >= 0) ITEMS[idx] = { ...ITEMS[idx], category, name, cal, img, tag }
        const oldKey = `${mCat.dataset.prevCategory}|${currentEditingName}`
        const newKey = `${category}|${name}`
        const cur = picked.get(oldKey)
        if (cur) { picked.delete(oldKey); picked.set(newKey, cur) }
      }
      mCat.dataset.prevCategory = category
      closecModal()
      render()
    })

    mDelete.addEventListener("click", () => {
      if (!currentEditingName) return
      deleteItem(currentEditingName)
      closecModal()
      render()

      const category = mCat.value.trim() || "Food"
      const idx = ITEMS.findIndex(x => x.name === currentEditingName && x.category === category)
      if (idx >= 0) ITEMS.splice(idx, 1)
      picked.delete(`${category}|${currentEditingName}`)
    })

    elcModal.addEventListener("click", e => {
      if (e.target === elcModal) closecModal()
    })

    // ---------- Quick Edit ----------
    const itemsToText = items => {
      return items.map(it => {
        const base = `${it.category} ${it.name} (${
          Math.max(0, parseInt(it.cal ?? 0, 10) || 0)
        })${it.img ? ` ${it.img}` : ""}`
        return it.tag ? `${base} | ${it.tag}` : base
      }).join("\n")
    }

    const textToItems = text => {
      return text.split("\n").map(line => {
        const raw = line.trim()
        if (!raw) return null
        const [left, tagRaw] = raw.split("|", 2)
        const m = left.trim().match(/^(\S+)\s+(.+?)\s*\((\d+)\)(?:\s+(.+))?$/)
        if (!m) return null
        return {
          category: m[1].trim(),
          name: m[2].trim(),
          cal: Math.max(0, parseInt(m[3], 10) || 0),
          img: (m[4] || "").trim(),
          tag: (tagRaw || "").trim()
        }
      }).filter(Boolean)
    }

    const openQuickEdit = () => {
      if (!elQModal) return
      elQText.value = itemsToText(ITEMS)
      elQModal.classList.remove("hidden")
      setTimeout(() => elQText.focus(), 0)
    }

    const closeQuickEdit = () => { elQModal?.classList.add("hidden") }

    elQuickEdit?.addEventListener("click", openQuickEdit)
    elQCancel?.addEventListener("click", closeQuickEdit)
    elQApply?.addEventListener("click", () => {
      const next = textToItems(elQText.value)
      const nextNames = new Set(next.map(i => i.name.toLowerCase()))
      for (const k of Array.from(picked.keys())) {
        if (!nextNames.has(k.toLowerCase())) picked.delete(k)
      }
      ITEMS = next
      closeQuickEdit()
      render()
    })
    elQModal?.addEventListener("click", e => {
      if (e.target === elQModal) closeQuickEdit()
    })

    // ---------- Render ----------
    const render = () => {
      document.body.classList.toggle("editing", editMode)
      elToggleEdit.classList.toggle("hidden", editMode)
      elAddItem.classList.toggle("hidden", !editMode)
      elSaveItems.classList.toggle("hidden", !editMode)
      elQuickEdit?.classList.toggle("hidden", !editMode)
      elPageEdit?.classList.toggle("hidden", !editMode)

      elGrid.innerHTML = ""
      const view = computeView()

      view.forEach((it, index) => {
        const k = keyOf(it)
        const isSel = picked.has(k)
        const count = picked.get(k) || 0

        const card = document.createElement("div")
        card.className = `card${isSel ? " selected" : ""}`
        card.dataset.name = it.name

        card.dataset.index = String(index)
        if (editMode) {
          card.setAttribute("draggable", "true")
          card.addEventListener("dragstart", e => startDrag(index, card))
          card.addEventListener("dragend", e => finishDrag(card))
          card.addEventListener("dragover", e => e.preventDefault())
          card.addEventListener("dragenter", e => {
            e.preventDefault()
            const rect = card.getBoundingClientRect()
            const before = (e.clientY - rect.top) < rect.height / 2
            if (!placeholder) return
            if (before) elGrid.insertBefore(placeholder, card)
            else elGrid.insertBefore(placeholder, card.nextSibling)
          })
        }

        const imgbox = document.createElement("div")
        imgbox.className = "imgbox"
        if (it.img && /^(https?:|\/)/.test(it.img)) {
          const img = document.createElement("img")
          img.src = it.img
          img.alt = it.name
          imgbox.appendChild(img)
        } else {
          const emoji = document.createElement("i")
          emoji.className = "emoji"
          const raw = it.img && it.img.trim() ? it.img : "üçΩÔ∏è"
          splitGraphemes(raw).forEach(g => {
            const span = document.createElement("span")
            span.textContent = g
            emoji.appendChild(span)
          })
          imgbox.appendChild(emoji)
        }

        const title = document.createElement("div")
        title.className = "title"
        title.textContent = it.name

        const cal = document.createElement("div")
        cal.className = "cal"
        cal.textContent = `${it.cal} cal`

        const cat = document.createElement("div")
        cat.className = "cal"
        cat.textContent = it.category

        const controls = document.createElement("div")
        controls.className = "controls"

        const minus = document.createElement("button")
        minus.className = "pill"
        minus.type = "button"
        minus.textContent = "-"
        minus.addEventListener("click", e => {
          e.preventDefault()
          e.stopPropagation()
          const cur = picked.get(k) || 0
          if (cur > 1) picked.set(k, cur - 1)
          else picked.delete(k)
          updateSubmit()
          render()
        })

        const cnt = document.createElement("div")
        cnt.className = "count"
        cnt.textContent = String(count)

        const plus = document.createElement("button")
        plus.className = "pill"
        plus.type = "button"
        plus.textContent = "+"
        plus.addEventListener("click", e => {
          e.preventDefault()
          e.stopPropagation()
          const cur = picked.get(k) || 0
          picked.set(k, cur + 1)
          updateSubmit()
          render()
        })

        controls.appendChild(minus)
        controls.appendChild(cnt)
        controls.appendChild(plus)

        if (!editMode) {
          card.addEventListener("click", (e) => {
            e.preventDefault()
            const cur = picked.get(k) || 0
            picked.set(k, cur + 1)
            updateSubmit()
            render()
          })
        }

        card.appendChild(imgbox)
        card.appendChild(title)
        // card.appendChild(cat)
        card.appendChild(cal)
        card.appendChild(controls)

        if (editMode) {
          const overlay = document.createElement("div")
          overlay.className = "card-overlay"
          const hint = document.createElement("div")
          hint.className = "hint"
          hint.textContent = "‚úèÔ∏è"
          overlay.appendChild(hint)
          overlay.addEventListener("click", e => {
            e.preventDefault()
            opencModal(it)
          })
          card.appendChild(overlay)
        } else if (isSel) {
          const badge = document.createElement("div")
          badge.className = "sticky-note"
          badge.textContent = "Added"
          card.appendChild(badge)
        }

        elGrid.appendChild(card)
      })
    }

    // ---------- Search / Submit / Edit toggle / Add / Save ----------
    elSearch.addEventListener("input", e => {
      query = e.target.value.trim()
      render()
    })

    elSubmit.addEventListener("click", () => {
      const byCat = new Map()

      for (const [key, count] of picked.entries()) {
        const [category, name] = key.split("|")
        const it = ITEMS.find(x => x.category === category && x.name === name)
        if (!it) continue
        const entry = byCat.get(category) || { parts: [], total: 0 }
        entry.parts.push(count > 1 ? `${name} x${count}` : name)
        entry.total += it.cal * count
        byCat.set(category, entry)
      }

      const lines = Array.from(byCat.entries()).map(([category, { parts, total }]) => {
        return `${category} ${parts.join(", ")} (${total})`
      })

      showFlash("Submitting...")
      lines.forEach(item => {
        command.socket.send({ action: "command", words: `log ${item}` })
      })
      picked.clear()
      render()
    })

    elToggleEdit.addEventListener("click", () => {
      editMode = !editMode
      render()
    })

    elAddItem.addEventListener("click", () => opencModal(null))

    const normalizeItems = items => {
      return items.map(it => ({
        category: String(it.category || "Food").trim(),
        name: String(it.name || "Untitled").trim(),
        cal: Math.max(0, parseInt(it.cal ?? 0, 10) || 0),
        img: (it.img || "").toString().trim(),
        tag: (it.tag || "").toString().trim(),
      }))
    }

    elSaveItems.addEventListener("click", async () => {
      const payload = { meal_builder: { items: normalizeItems(ITEMS) } }

      const res = await fetch(SAVE_ENDPOINT, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          "X-CSRF-Token": csrfToken(),
          "Accept": "application/json"
        },
        body: JSON.stringify(payload),
        credentials: "same-origin"
      })

      if (res.ok) {
        showFlash("Saved! ‚úÖ")
        editMode = false
        render()
        return
      }

      const err = await res.text().catch(() => "")
      console.error("Save failed", res.status, err)
      alert("Save failed")
    })

    // ---------- Boot ----------
    document.addEventListener("DOMContentLoaded", () => {
      render()
      updateSubmit()
    })
  </script>
<% end %>
